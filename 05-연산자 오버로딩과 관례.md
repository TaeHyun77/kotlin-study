언어 기능을 타입에 의존하는 자바와 달리, 코틀린은 함수 이름을 통한 관례에 의존함

자바는 기능 사용을 위해 반드시 관련된 인터페이스나 클래스를 ’구현(implement)’해야만 해당 기능을 사용할 수 있는 구조
즉, 문법적 기능을 쓰려면, 정해진 타입(인터페이스/클래스)을 따라야 한다는 것
```
// 자바에서 for-each 문을 사용하려면 Iterable<T>를 반드시 구현해야 함
public class MyList implements Iterable<String> {
    public Iterator<String> iterator() {
        // 반복자 로직
    }
}
```
<br>

하지만, 코틀린은 타입을 따르지 않아도, 함수 이름이 정해진 규칙( 관례 )을 따르면 언어 기능이 동작<br><br>
```
class MyList {
    operator fun iterator(): Iterator<String> {
        // 반복자 로직
    }
}
```
<br>

자바에서 Comparable 인터페이스를 구현하면 compareTo() 메서드를 정의할 수 있음

```jsx
class User implements Comparable<User> {
    public int compareTo(User other) {
        // ...
    }
}
```

여기서는 타입을 구현했기 때문에 Collections.sort() 같은 기능이 작동 ⇒ 타입 기반<br><br>

코틀린에서는 compareTo()라는 이름의 함수를 정의하면 자동으로 <, > 연산자를 사용할 수 있음

```jsx
class User(val score: Int) {
    operator fun compareTo(other: User): Int {
        return this.score - other.score
    }
}

val a = User(100)
val b = User(90)

println(a > b) // compareTo 호출됨
```

여기서 compareTo()라는 이름만 맞추면, 별도의 인터페이스 구현 없이도 <, >를 사용할 수 있음 ⇒ 관례 기반<br><br>

### 산술 연산자 오버로딩

---

코틀린에서 관례를 사용하는 가장 단순한 예는 산술 연산자임

자바에서는 원시 타입에 대해서만 산술 연산자를 사용할 수 있고, 추가로 String에 대해 + 연산자를 사용할 수 있음

하지만, 컬렉션에 원소를 추가할 때 += 연산자를 사용하거나, BigInteger 클래스에서 add() 메서드 대신 + 연산자를 사용하는 방식이 더 낫지만 자바에서는 이런 연산자 사용이 불가능하며, 반드시 메서드를 명시적으로 호출해야 함

하지만, 코틀린은 연산자 오버로딩을 지원하기 때문에 가능함 !

**이항 산술 연산 오버로딩 ( 두 개의 값에 대해 작용하는 연산 )**

두 점의 좌표를 각각 더하는 연산 함수 정의

```jsx
data class Point(val x: Int, val y: Int) {
	operator fun plus(other: Point): Point {
		return Point(x + other.x y + other.y)
	}
}

val p1 = Point(10, 20)
val p2 = Point(30, 40)
print(p1 + p2) // Point(x=40, y=60)
```

연산자를 오버로딩 하는 함수 앞에는 꼭 operator가 있어야 함

⇒ 어떤 함수가 관례를 따르는 함수인지 명확히 할 수 있음

( 만약, operator가 없는데 실수로 관례에서 사용하는 함수 이름을 쓰고 그 이름에 해당하는 기능을 사용한다면 오류가 발생함 )

operator 변경자를 추가하여 plus 함수를 선언하고 나면 + 기호로 두 Point 객체를 더할 수 있음

→ `a + b`는 `a.plus(b)`로 컴파일 됨

```jsx
// 확장 함수로도 정의할 수 있음
operator fun Point.plus(other Point) {
	return Point(x + other.x y + other.y)
}
```

코틀린에서는 프로그래머가 직접 연산자를 만들어 사용할 수 없고 언어에서 미리 정해둔 연산자만 오버로딩 할 수 있으며, 관례를 따르기 위해 클래스에서 정의해야 하는 이름이 연산자별로 정해져 있음

 

| 식 | 함수 이름 |
| --- | --- |
| a * b | times |
| a / b | div |
| a % b | mod |
| a + b | plus |
| a - b | minus |

연산자를 정의할 때 두 피연산자가 같은 타입일 필요는 없음

어떤 점을 비율에 따라 확대/축소하는 연산자를 정의해보자면

```jsx
operator fun Point.times(scale: Double): Point {
	return Point((x * scale).toInt(), (y * scale).toInt())
}

val p = Point(10, 20)
print(p * 1.5) // Point(x=15, y=30)
```

주의 )

코틀린 연산자는 자동으로 교환 법칙을 지원하지 않음

즉, `p * 1.5`는 `1.5 * p`와 다름

사용하고 싶다면 `operator fun Double.times(p: Point): Point`를 따로 정의해야 함

또한, 연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나와 일치해야하는 것도 아님

```jsx
operator fun Char.times(cnt: Int): String {
	return toString().repeat(cnt)
}

print('a' * 3) // aaa
```

**복합 대입 연산자 오버로딩**

복합 연산자 : `+=`, `-=`, `*=` 등등 …

plus와 같은 연산자를 오버로딩하면 코틀린은 + 연산자뿐만 아니라 +=도 자동으로 함께 지원해줌

```jsx
// 즉 위의 Point +를 이렇게 바꿀 수 있음
val p1 = Point(10, 20)
p1 += Point(30, 40)
print(p1) // Point(x=40, y=60)
```

경우에 따라 +=  연산이 객체에 대한 참조를 다른 참조로 바꾸기보다 원래 객체의 내부 상태를 변경하게 만들고 싶을 때가 있음

즉, 변경 가능한 컬렉션에 원소를 추가하는 경우

```jsx
val numbers = ArrayList<Int>()
numbers += 42
print(numbers[0]) // 42
```

반환 타입이 Unit인 plusAssign 함수를 정의하면 코틀린은 += 연산자에 그 함수를 사용함

( minusAssign, timesAssign 등등도 존재 .. )

코틀린 표준 라이브러리는 변경 가능한 컬렉션에 대해 plusAssign을 정의하기 때문에 앞선 예제처럼 사용 가능

> operator fun <T> MutableCollection<T>.plusAssign(element: T) { this.add(element) }
> 

만약 어떤 클래스가 plus와 plusAssign를 모두 정의하고 있다면 +와 +=을 모두 사용할 수 있는데

, 이 경우 컴파일러는 오류를 일으킴

⇒ 일반 연산자를 사용하는 등의 방법으로 해결 가능 하지만 plus와 plusAssign을 같이 정의하지 않는 것을 권장

코틀린의 +와 -는 항상 새로운 컬렉션을 반환하며, +=와 -=연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변화시키고, 읽기 전용 컬렉션에서 +=과 -=는 변경 가능한 복사본을 반환함

( 따라서, 읽기 전용 컬렉션에서 +=과 -=는 val로 선언 되어 있을 때만 사용 가능  )

**단항 연산 오버로딩 ( 한 값에만 작용하는 단항 연산자 )**

단항 연산자를 오버로딩하는 절차도 이항 연산자와 동일함

```jsx
operator fun Point.unaryMinus(): Point {
	return Point(-x, -y)
}

val p = Point(10, 20)
print(-p) // Point(-10, -20)
```

단항 연산자를 오버로딩 하기 위해 사용하는 함수는 인자를 갖지 않음

| 식 | 함수 이름 |
| --- | --- |
| +a | unaryPlus |
| -a | unaryMinus |
| !a | not |
| ++a, a++ | inc |
| - -a, a- - | dec |

inc나 dec 함수를 정의하여 증가/감소 연산자를 오버로딩 하는 경우 컴파일러는 일반적인 값에 대한 전위와 후위 증가/감소 연산자와 같은 의미를 제공

```jsx
operator fun BigDecimal.inc() = this + BigDecimal.ONE

var bd = BigDecimal.ZERO
print(bd++) // 0
print(++bd) // 2
```

### 비교 연산 오버로딩

---

코틀린에서는 산술 연산자와 마찬가지로 원시 타입 값뿐 아니라 모든 객체에 대해 비교 연산을 수행 가능

자바에서는 equals나 compareTo를 호출해야 하지만, 코틀린에서는 == 을 통해 사용 가능하므로 편함

- equals
    
    코틀린에서는 == 연산자가 equals를 호출하고 != 연산자도 equals를 호출함
    
    ==와 !=은 내부에서 null 검사를 하므로 다른 연산과 달리 null이 될 수 있는 값에도 적용 가능
    
    ( `a == b` → `a?.equals(b) ?: ( b == null )` )
    

Point의 경우 데이터 클래스이므로, 컴파일러가 자동으로 equals를 생성해줌, 하지만 직접 구현한다면 

```jsx
class Point(val x: Int, val y: Int) {
	override fun equals(obj: Any?): Boolean {
		if (obj === this) return true
		if (obj !is Point) return false
		
		return obj.x == x && obj.y == y
	}
}
```

equals는 Any에 정의된 메서드므로 override가 필요함

그럼 왜 operator는 붙이지 않을까 ? ⇒ Any의 equals에 이미 붙어있기 때문

> `public open operator fun equals(other: Any?): Boolean`
> 

⭐️ 하지만 equals를 확장 함수로는 정의할 수는 없음 → Any의 equals가 우선 순위가 더 높기 때문

- compareTo - 순서 연산자
    
    자바에서 정렬, 최대값, 최소값 등 값을 비교할 때는 Comparable 인터페이스를 구현함
    
    Comparable의 compareTo 메서드는 한 객체와 다른 객체의 크기를 비교하여 정수로 나타내주는데
    
    , 자바에서는 이 메서드를 간단히 호출할 방법이 없음 ( `a.compareTo(b)` 이런 식으로만 함 )
    
    코틀린에서도 Comparable 인터페이스를 지원하고, compareTo 메서드 호출의 관례를 제공함
    
    ⇒ < , >, ≤, ≥ 비교 연산자는 compareTo 호출로 컴파일 됨 ( Int 반환하는 것은 똑같음 )
    
    ⇒ `p1 < p2` 는 `p1.compareTo(p2) < 0`과  같음 
    
    ```jsx
    // 성을 비교하고 같으면 이름을 비교하는 예제
    class Person (val firstName: String, val lastName: String): Comparable<Person> {
    	override fun compareTo(other: Person): Int {
    		return compareValuesBy(this, other, Person::lastName, Person::firstName)
    	}
    }
    
    val p1 = Person("Alice", Smith")
    val p2 = Person("Bob", "Johnson")
    print(p1 < p2) // false
    ```
    
    <aside>
    💡
    
    fun <T, R : Comparable<R>> compareValuesBy(
      a: T, b: T,
      vararg selectors: (T) -> R?
    ): Int
    
    ⇒ 
    
    a, b: 비교할 두 객체
    
    selectors: 비교 기준으로 사용할 프로퍼티 
    
    </aside>
    
    equals와 마찬가지로 operator 키워드가 이미 Comparable내에서 정의되어 있고 이를 override 했기 때문에 operator를 따로 붙여줄 필요는 없음
    

### 컬렉션과 범위에 대해 쓸 수 있는 관례

---

**인덱스로 원소 접근 : get과 set**

`public operator fun get(index: Int): Int`

`public operator fun set(index: Int, value: Int): Unit`

코틀린과 자바에서 인덱스로 원소에 접근할 때는 []를 통해 접근하게 되는데, 코틀린에서는 인덱스 연산자도 관례를 따름 !

코틀린에서 인덱스 연산자 []는 get 연산자 메서드로 변환되고, 원소를 쓰는 연산은 set으로 변환됨

`a[1]과 같은 인덱스 접근 표현은 컴파일 시에 a.get(1)로 변환되며, 해당 클래스에 정의된 get 메서드를 통해 실제 동작이 수행됨`

`마찬가지로 a[1] = value와 같은 할당 표현은 a.set(1, value)로 변환되어, 클래스에 구현된 set 메서드를 통해 값이 저장됨`

- get
    
    ```jsx
    operator fun Point.get(index: Int): Int {
    	return when(index) {
    		0 -> x
    		1 -> y
    		else -> 
    			throw ...
    	}
    }
    
    val p = Point(10, 20)
    print(p[1]) // 20
    
    //  p[1]은 p.get(1)으로 해석되고 
    ```
    
    get 메서드의 파라미터로 항상 Int가 올 필요는 없음
    

- set
    
    ```jsx
    data class MutablePoint(var x: Int, var y: Int) 
    
    operator fun MutablePoint.set(index: Int, value: Int) {
    	when(index) {
    		0 -> x = value
    		1 -> y = value
    		else ->
    			throw ...
    	}
    }
    ```
    

**in 관례**

in 연산자는 객체가 컬렉션에 존재하는지 검사하는 역할을 함

in 연산자와 대응하는 함수는 contains임

코틀린에서 in 연산자는 contains 연산자로 컴파일 됨 ⇒ `1 in c`은 `c.contains(1)`과 같음

```jsx
// 어떤 점이 사각형 안에 들어가는지 판단하는 예제

data class Rectangle(val upperLeft: Point, val lowerRight: Point) 

operator fun Rectangle.contains(p: Point): Boolean {
	return p.x in upperLeft.x until lowerRight.x &&
		p.y in upperLeft until lowerRight.y
}

val rect = Rectangle(Point(10, 20), Point(50, 50))
print(Point(20, 30) in rect) // true
```

**rangeTo 관례**

범위를 만드려면 .. 구문을 사용해야 함 → 1..10은 1 ~ 10까지의 범위를 나타냄

`start .. end`는 `start.rangeTo(end)`와 같음 

rangeTo 함수는 범위를 반환함, 이 연산자를 아무 클래스에나 정의할 수 없지만 어떤 클래스가 Comparable 인터페이스를 구현한다면 rangeTo를 정의할 필요가 없음

⇒ Kotlin 표준 라이브러리에 이미 Comparable을 위한 rangeTo가 정의되어 있기 때문

> `operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = …`
> 

이 함수는 범위를 반환하며, 어떤 원소가 그 범위 안에 있는지 in을 통해 검사 가능

```jsx
// 날짜의 범위를 다루는 예제

val now = LocalDate.now()
val vacation = now..now.plusDays(10)
print(now.plusWeeks(1) in vacation) // true
```

어떻게 `now..now.plusDays(10)` 식이 가능할까 ⇒ LocalDate가 Comparable를 구현하고 있기 때문

`now..now.plusDays(10)` 식은 `now.rangeTo(now.plusDays(10))`으로 변환됨

**for 루프를 위한 iterator 관례**

for 루프는 범위 검사와 똑같이 in 연산자를 사용하지만 이 경우 in의 의미는 다름

`for ( x in list ){ … }` 와 같은 문장은 list.iterator()를 호출하여 이터레이터를 얻은 다음, 자바와 마찬가지로 이터레이터에 대해 hashNext와 next 호출을 반복하는 식으로 변환됨

```jsx
for ( x in list ){ … }은 내부적으로 아래와 같이 변환됨

↓↓↓↓↓↓

val iterator = list.iterator()

// hasNext(): 다음 요소가 있는지 확인, next(): 다음 요소를 꺼냄
while (iterator.hasNext()) {
    val x = iterator.next()
    println(x)
}
```

⇒ 이 또한 관례이므로 iterator() 메서드를 확장 함수로 정의할 수 있음

이런 성질로 인해 일반 자바 문자열에 대한 for 루프가 가능함 → CharIterator에 대한 iterator() 확장 함수 제공

> `operator fun CharSequence.interator(): CharIterator`
> 

클래스 안에 직접 iterator 메서드를 구현할 수도 있음

```jsx
// 날짜에 대해 iteratoration 하는 코드

operator fun CloseRange<LocalDate>.iterator(): Iterator<LocalDate> =

	object: Iterator<LocalDate> {
		var current = start
		
		override fun hashNext() =
			current <= endInclusive
		
		override fun next() = current.apply {
			current = plusDays(1)
		}
	}
}

val newYear = LocalDate.ofYearDay(2017, 1)
val daysOff = newYear.minusDays(1)..newYear

for (dayOff in daysOff) { print(dayOff) }// 2016-12-31 2017-01-01
```

newYear.minusDays(1)..newYear는 ClosedRange<LocalDate> 를 생성하지만 

( ..은 내부적으로 rangeTo로 변환되고 rangeTo는  ClosedRange<LocalDate>를 반환하기 때문 )

ClosedRange<LocalDate>에는 Iterator()가 정의되어 있지 않기 때문에 사용하려면 이를 정의해줘야 함
