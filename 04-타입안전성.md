코틀린에서는 자바와는 다르게 null이 될 수 있는 타입과 읽기 전용 컬렉션을 제공 

null 가능성은 NPE를 피할 수 있게 해주는 코틀린 타입 시스템의 특성임

자바는 null 오류를 런타임에 체크하지만, 코틀린은 컴파일 타임에 체크하기에 null 오류를 방지할 수 있음

```jsx
// Java 코드, s가 null 일 때 런타임에 NPE 발생
int strLen(String s) {
	return s.length();
}

// 코틀린 코드, s가 null 일 때 컴파일 시 오류가 발생
fun strLen(s: String) = s.length
```
<br>

### Null 기능 참조

---

Java에서 null은 항상 오류를 유발할 가능성이 있음

만약 어느 객체를 리턴하는 함수가 호출에서 리턴할게 아무것도 없다면 Java에서는 null이 리턴되고

, 이런 방식은 null 체크를 하지 않았을 경우 NullPointerException을 야기함

⇒ 최근에는 Optional을 통해 해결하고 있지만 Optional을 사용해야 한다는 점, 오버헤드가 발생한다는 점, Optional이 아니고 null을 리턴하더라도 Java 컴파일러는 별 다른 경고를 발생시키지 않는다는 문제가 존재

하지만, 코틀린에서는 이러한 이슈가 없고 컴파일 시간에 null 체크 여부를 확인시켜줌<br><br>

**null은 에러를 유발함**

Java에서는 객체가 리턴되어야 할 메서드에서 null을 리턴하는 코드를 짜는 것을 막을 수 없기에

, Optional을 사용하는 방법을 선택 → 언제 어디서 사용할지, 오버헤드가 발생하는 문제 야기

따라서 코틀린은 이를 좋게 해결 !

⇒ null을 null 불가 참조에 할당하거나 참조 타입이 null 불가인 곳에 null을 리턴하면 컴파일 오류가 발생

```llvm
fun nickName(name: String): String {
	if(name == "asd") {
		return "qwe"
	} 
	return null; // Error 발생
}

println("${nickName("asd")}") // qwe
println("${nickName(null)}") // Error 발생
```

위와 같은 코드는 Java에서는 컴파일은 잘 되고 런타임에 오류가 나겠지만, 코틀린은 오류를 유발하는 코드를 작성하는 것을 원하지 않음

즉, 예를 들어 리턴 타입이 String인데 null을 반환하게 하지 않거나 null을 인자로 넘기지 못하게 함

### 안전한 호출 연산자( Safe Call Operator ) ?.

---

객체가 null이 아닐 경우에만 그 뒤의 속성이나 함수를 호출하도록 해주는 연산자

Ex) `s?.toUpperCase()`는 `if (s ≠ null) s.toUpperCase() else null` 과 같음

?. 호출 결과 타입은 null이 될 수 있는 타입이 됨

예제

```jsx
class Address(val streetAddress: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun Person.countryName(): String {
	val country = this.company?.address?.country
	
	return if(country != null) country else "unkown"
}
```

↓↓↓↓↓ 엘비스 연산자 ?:를 통해 개선 가능 ( null 대신 사용할 디폴트 값을 지정할 때 사용 )

```jsx
class Address(val streetAddress: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun Person.countryName(): String = this.company?.address?.country ?: "unkown"
```

코틀린에서는 return이나 throw등의 연산도 식이므로 엘비스 연산자 우항에 return, throw 작성 가능

```jsx
class Address(val streetAddress: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun printShippingLabel(person: Person) {
	val address = person.company?.address
		?: throw ~
	
	whth (address) { // obj가 non-null이라는 전제 하에 코드 블록 실행
		print(streetAddress)
	}
}
```

**when의 사용**

?. 연산자나 ?: 보다는 when 사용을 고려하여 코드의 로직을 쉽게 만들고 가독성을 높이자 !

즉, 세이프 콜 연산자나 Elvis 연산자는 값을 추출할 때 사용하고, when은 null 가능 참조에 대한 처리를 결정해야 할 때 사용해라

```llvm
fun nickName(name: String?): String {
	if(name ="asd") {
		return "qwe"
	} 
	return name?.reverse()?.toUpperCase() ?: "Joker"
}

↓↓↓↓↓↓↓↓↓↓↓↓↓↓

fun nickName(name: String?) = when(name) {
	"asd" -> "qwe"
	null -> "Joker"
	else -> name.reverse().toUpperCase()
}
```

`when`을 사용하면 null 여부를 명확히 분기할 수 있어, 세이프 콜 연산자와 Elvis 연산자를 생략하면서도 더 깔끔하고 안전한 코드를 작성할 수 있음 

### 타입 체크와 캐스팅

---

⭐️⭐️

> if, &&, ||, when 등의 조건문에서 타입 검사를 하면
> 

> 해당 블록 내부에서는 별도의 형변환 없이 스마트 캐스팅이 자동으로 적용됨
> 

**타입 체크**

실행 시간에 타입을 체크하는 행위는 가끔씩 필수적이지만 새로운 타입이 추가되었을 때 OCP를 위배하므로 

, 실행 시간에 타입 체크를 진행할지 여부는 코드를 짜기 전 생각 해보는게 좋음

하지만 equals() 메서드를 구현한다던지, when을 사용할 때는 반드시 타입 체크를 해야만 함

따라서, 실행 시간에 타입체크는 어떻게 하는지, 타입 확인 후 캐스팅을 할 때 불편함을 덜어주는 기능을 보자

**is 사용하기**

`어떤 객체가 특정 타입인지 검사하는 데 사용됨, 자바의 instanceof에 해당하는 연산자`

`예상된 타입이라면 true를, 아닐 경우 false를 리턴`

Object의 equals() 메서드는 참조 기반 비교이지만, 클래스에서 equals() 메서드를 참조가 아닌 동일성을 파악하기 위해 오버라이드 할 수도 있음

```llvm
class Animal {
	override operator fun equals(other: Any?) = other is Animal
}
```

is 연산자는 모든 타입의 참조에 사용될 수 있음 만약, 참조가 null인 경우 is 연산 결과는 false를 리턴하고

, is 연산자 뒤의 타입이 객체의 타입과 같거나 상속관계에 있다면 true를 리턴

is 연산자는 또한 부정과 함께 사용할 수 있음 ⇒ other !is Animal과 같이 사용 가능

**스마트 캐스트**

Animal 클래스에 age 속성이 있다고 한다면, 그리고 그 객체를 비교할 때 그 속성을 사용한다고 한다면

자바에서의 equals() 메서드 오버라이드에서는 ((Animal) other) 와  같이 캐스팅을 해줘야 사용이 가능

```llvm
@Override
public boolean equals(Object object) {
	if (object instanceof Animal) {
		return age == ((Animal) object).age;
	}
	return false
}
```

하지만 코틀린에서는 참조의 타입이 확인되면 자동 혹은 스마트 캐스팅을 해줌

```llvm
override operator fun equals(other: Any?):Boolean {
	return if (other is Animal) age == other.age else false
}
```

equals() 메서드 안에서 캐스트 없이 other.age처럼 바로 사용할 수 있음

⇒ if 문의 조건에서 other가 Animal인지 확인했기 때문

스마트 캐스트는 if문뿐만 아니라 || 연산자 혹은 && 연산자 이후에도 작동 ( 아래와 같이 변경 가능 )

```llvm
override operator fun equals(other: Any?) = 
	other is Animal && age = other.age
```

**when과 함께 타입 체크와 스마트 캐스트 사용하기**

when 명령문 또는 표현식에 is나 !is, 스마트 캐스팅을 사용할 수 있음

```llvm
fun printWhatToDo(dayOfWeek: Any) {
	when (dayOfWeek) {
		"saturday", "sunday" -> println("Relax")
		in listOf("Monday", "Tuesday", "Wednesday", "Thursday") -> println("Work hard")
		in 2..4 -> println("Work hard")
		is String -> println("what? ${dayOfWeek.length}")
		"Friday" -> println("Party")
	}
}
```

is String -> "what? ${dayOfWeek.length}" 이 부분에서 is 를 통해 타입 체크를 했으므로

dayOfWeek는 자동으로 String으로 캐스팅 되니까 String의 메서드를 사용할 수 있음

### 안전한 캐스트 as? ( 명시적 타입 캐스팅 )

---

타입 캐스트 연산자인 as를 사용했을 때 만약 캐스트가 불가능하다면 예외가 발생함

```jsx
val obj: Any = "Hello"
val str: String = obj as String
---
val obj: Any = 123
val str: String = obj as String  // 예외 발생: java.lang.ClassCastException
```

따라서 is로 캐스트 가능한지 확인 후 as를 사용할 수 있지만 복잡하기에, as?를 사용 

→ 캐스트 불가능하면 null 반환

```jsx
class Person(val firstName: String, val lastName: String) {
	override fun equals(o: Any): Boolean {
	
		val otherPerson = o as ? Person ?: return false
		
		return otherPerson.firstName == firstName &&
			otherPerson.lastName == lastName
	}
	
	override fun hashCode(): Int =
		firstName.hashCode() * 37 + lastName ~
}
```

### !! 연산자 → 웬만하면 사용하지 말기 ..

---

컴파일러에게 어떤 값이 null이 아니라는 것을 명시 해주는 연산자, null 아님 단언

null이 될 수 없는 타입으로 강제로 바꿀 수 있음

만약 s에 null이 대입되면 들어오면 예외가 발생함

```jsx
fun ignoreNulls(s: String?) {
	val a: String = s!!
	print(a.length)
}
```

!! 연산자를 사용하는 경우도 있음

어떤 함수가 null 여부를 검사한 뒤 다른 함수를 호출하더라도, 컴파일러는 호출된 함수 내부에서 해당 값이 null이 아님을 정확히 인식하지 못할 수 있지만, 호출된 함수가 항상 null이 아닌 값을 전달받는다는 것이 확실하다면, 매번 null 검사를 반복하고 싶지 않을 수 있음

이런 경우에는 !! 연산자를 사용하여 컴파일러에게 해당 값이 절대 null이 아님을 명시적으로 알려줄 수 있음

!! 연산자를 사용할 때 예외가 발생하면, 예외가 발생한 줄 번호는 표시되지만 어떤 식에서 null이었는지에 대한 정보는 제공되지 않음

따라서 `person.company!!.address!!.country`처럼 여러 !!를 한 줄에 연달아 사용하는 방식은 지양해야 함

```jsx
person
    .company!!
    .address!!.country
    
쓸거면 이런 식으로 사용
```

### let 연산자

---

null이 아닌 경우에만 특정 블록을 실행하고 싶을 때 사용하는 연산자

→ 여러 문장을 작성하거나, 객체명을 it 대신 다른 이름으로 바꾸고 싶을 때 사용

`email.let { email → sendEmailTo(email) }`

`email.let { sendEmailTo(it) } 으로 축약 가능`

```jsx
fun sendEmailTo(email: String) {
	print("$email")
}

var email: String? = "asd"
email?.let {sendEmailTo(it)}

// 만약 it이 null이면 이는 무시됨
```

```jsx
val person: Person? = getPerson()
if (person != null) sendEmailTo(person.email)
```

↓↓↓↓↓↓↓↓

```jsx
getPerson()?.let {sendEmailTo(it.email)} 이렇게 변경 가능
```

### **나중에 초기화 할 프로퍼티**

---

객체 인스턴스를 일단 생성한 다음 나중에 초기화하는 프레임 워크가 많지만, 코틀린에서는 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메서드 안에서 초기화 할 수 없음

즉, 일반적으로 생성자에서 모든 프로퍼티를 초기화 해야함

널이 될 수 없는 타입이라면 null이 아닌 값으로 반드시 초기화 해야하지만, 아니라면 널이 될 수 있는 타입을 사용할 수 밖에 없음 

→ 이렇게 하면 모든 프로퍼티 접근에 널 검사를 하거나 !!을 사용해야 함

```jsx
class MyService {
	fun performAction(): String = "foo"
}

class MyTest {
	private var myService: MyService? = null
	
	@Before fun setUp() {
		myService = MyService()
	}
	
	@Test fun testAction() {
		Assert.assertEquals("foo", myService!!.performAction())
	}
}
```

테스트 실행 전에 인스턴스를 할당했으니 !! 연산자 없이 써도 되지 않나? 라고 생각할 수 있는데 

코틀린 컴파일러는 `@Test` 실행 전 `@Before`를 통해 초기화 된다는 것을 알지 못하므로 명시적으로 체크해야 함

코드의 가독성이 좋지 않으므로, lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있음

```jsx
class MyService {
	fun performAction(): String = "foo"
}

class MyTest {
	private lateinit var myService: MyService
	
	@Before fun setUp() {
		myService = MyService()
	}
	
	@Test fun testAction() {
		Assert.assertEquals("foo", myService.performAction())
	}
}
```

⇒ lateinit을 통해 나중에 반드시 초기화될 것을 보장하여 컴파일러가 오류를 발생시키지 않음

`나중에 초기화하는 프로퍼티는 항상 var이어야 함` ⭐️⭐️

### **널이 될 수 있는 타입 확장**

---

일반 멤버 함수는 클래스 내부에서 정의되기 때문에 객체가 null 이면 호출 자체가 불가능하지만, 확장 함수는 정적 디스패치 기반이기 때문에, 컴파일러는 null 여부와 상관없이 함수 호출 코드를 생성할 수 있음

원래는 nullable 한 변수에서 메서드를 호출할 때는 `(nullableVar)?.method()`처럼 safe call (?.)을 사용해야 하지만, 확장 함수를 nullable 수신 객체(T?)를 대상으로 직접 정의하면 그냥 `(nullableVar).method()`처럼 safe call 없이도 호출할 수 있음

→ 직접 정의할 때는 메서드 내에서 null 처리를 명시적으로 해줘야 함

nullable 수신 객체를 대상으로 하는 Kotlin의 기본 제공 확장 함수는 isNullOrEmpty(), isNullOrBlank(), orEmpty() 등등이 존재

---

```jsx
fun String?.printSafe() {
    if (this == null) {
        println("값이 없습니다")
    } else {
        println("문자열 길이: ${this.length}")
    }
}

val name: String? = null
name.printSafe() // "값이 없습니다", 이렇게 호출 가능
```

### **타입 파라미터의 null 가능성**

---

코틀린에서는 함수나 클래스의 모든 파라미터는 기본적으로 null이 될 수 있는데

타입 파라미터 T를 사용할 때는 ?가 없더라도 nullable 타입임

```jsx
fun <T> printHashCode(t: T) {
    print(t?.hashCode())
}
```

t는 nullable이므로 ?를 통해 안전하게 다뤄야하며, T의 타입 추론은 Any?로 됨

하지만 `fun <T: Any> printHashCode(t: T) …`  이렇게 해버리면 T는 non-nullable이 됨

즉, 하고자 하는 말은 타입 파라미터 T는 nullable일 때 ?를 생략해도 되는 특별한 경우임

### **널 가능성과 자바 - 플랫폼 타입**

---

코틀린은 자바와 상호 운용성을 강조하는데 자바에는 널 가능성을 지원하지 않음

→ 그럼 자바와 코틀린을 조합하면 어떻게 될까 ? 안전하지 않게 되지 않을까 ? 모든 값을 null 체크 해야하나 ?

자바에도 어노테이션으로 표시된 널 가능성 정보가 있으며, 이런 정보가 있다면 코틀린도 그 정보를 활용함

⇒ `@Nullable String` 은 String?과 같고, `@NotNull String`은 String과 같음

즉, 코틀린은 이러한 어노테이션을 통해 null 을 이해할 수 있음

하지만, 자바 코드에 null 관련 어노테이션이 없으면, Kotlin에서는 해당 타입을 `플랫폼 타입`으로 간주함

> 플랫폼 타입 : Kotlin이 해당 타입의 null 가능성을 정확히 알 수 없는 상태를 의미함
> 

따라서 이 타입은 nullable로도 non-nullable로도 사용할 수 있으며, null 안전성에 대한 책임은 전적으로 개발자에게 있음

코틀린인 널이 될 수 없는 값에 대해 null 안전성 검사를 하게되면 컴파일러가 경고를 표시하지만, 플랫폼 타입에 대해서는 널 안정성 검사를 중복 수행해도 경고 표시를 하지 않음

```jsx
public class Person {
	private final String name;
	
	public Person(String name) {
		this.name = name
	}
	
	public String getName() {
		return name
	}
}
```

⇒ getName은 null을 리턴할까 아닐까 ?

코틀린 컴파일러는 이 경우 String 타입의 널 가능성에 대해 전혀 알지 못함 

따라서, 널 가능성을 개발자가 직접 처리해야만 함

이 변수가 널이 아님을 확신할 수 있다면 추가 검사 없이 이를 참조할 수 있지만 추가 검사를 하지 않으면 예외가 발생할 수 있음을 염두해 둬야함

코틀린은 public 함수의 널이 아닌 타입인 파라미터와 수신 객체에 대한 Null 검사를 해줌

⇒ 오류를 빠르게 파악할 수 있음

자바 api를 사용할 때는 주의해야함 → 대부분의 라이브러리는 널 관련 어노테이션을 사용하지 않으므로 

null을 반환할지를 파악하고 반환한다면 검사를 추가적으로 해줘야 함

```jsx
특히 제네릭을 다룰 때 더 상황이 안좋음
자바의 ArrayList<String>을 코틀린에서 ArrayList<String?>? 처럼 다루게 되면 모든 원소에 접근할 때
마다 null 검사를 해줘야하고, 안전 캐스트를 수행해야 함
-> 이는 null 안정성으로 얻는 이익보다 검사에 비용이 더 큼

따라서 개발자가 그 타입을 제대로 처리할 책임을 부여도록 권고함
```

코틀린에서는 플랫폼 타입을 선언할 수는 없고 자바 코드에서 가져온 타입만 플랫폼 타입이 됨

>>> val i: Int = person.name

ERROR: Type mismatch: inferrd type is String! but ~

여기서 코틀린 컴파일러가 표시한 String! 타입은 자바 코드에서 온 타입임, 하지만 이 타입은 코틀린에서 사용할 수 없음, ! 표기는 널 가능성에 대해 아무 정보도 없다는 뜻임

어쨋든 

val s: String? = [person.name](http://person.name) 이나 val s: String = person.name 모두 사용할 수는 있지만 내가 알아서 처리해야 함

**상속**

코틀린에서는 자바 메서드를 오버라이드할 때 그 메서드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야 함

```jsx
interface StringProcessor {
	void process(String value)
}
```

위처럼 됐을 때 코틀린에서 이를 구현하게 되면 코틀린 컴파일러는 String이나 String? 구현을 모두 받아들임

### 코틀린의 원시 타입

---

코틀린은 원시 타입과 래퍼 타입을 구분하지 않음

**원시 타입 Int, Boolean …**

자바는 원시 타입과 참조 타입을 구분하지만 메서드를 호출하거나 컬렉션에 원시 타입 값을 담을 수는 없으며

Interger와 같은 래퍼 타입으로 원시 타입 값을 감싸서 사용함

```jsx
int x = 10;
x.toString(); // 컴파일 오류 ..

List<int> arr = new ArrayList<>() // 컴파일 오류 ..
```

코틀린은 이를 구분하지 않기에 정수를 표현할 때는 Int를 사용 

→ 래퍼 타입을 따로 구분하지 않기에 편리함 또한 원시 타입에 대해 메서드 호출이 가능함

원시타입과 참조 타입이 같다면 코틀린은 이를 항상 객체로 표현하는건가 ? 하지만, 코틀린은 그러지 않음

실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현됨

코틀린의 Int 타입은 자바 int 타입으로 컴파일되고, 이런 식으로 되는 것이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우뿐임

⇒ Int 타입을 컬렉션 파라미터로 넘기면 Integer 객체가 들어감

Kotlin의 Int는 null이 될 수 없기 때문에, Java의 int처럼 원시 타입으로 안전하게 컴파일할 수 있음

Int?를 넘기면 Integer로 변환됨 ..

**널이 될 수 있는 원시 타입**

null 참조를 자바의 참조 타입의 변수에만 대입할 수 있기에 null이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없음

따라서, 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 내부적으로 자바의 래퍼 클래스로 컴파일됨

**숫자 변환**

코틀린과 자바의 큰 차이점 중 하나는 숫자를 변환하는 방식임

코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않음

결과 타입이 허용하는 숫자의 범위가 원래 타입의  범위보다 넓은 경우조차 자동 변환은 불가능함

`val i = 1`

`val i: Long = i // 오류 발생`

대신 직접 변환 메서드를 호출해야 함

`val i = 1`

`val l: Long = i.toLong()`

코틀린은 모든 원시 타입에 대한 변환함수를 제공함

toByte(), toShort(), toChar() 등등 ..

**원시타입 리터럴**

Kotlin에서는 숫자 리터럴을 사용할 때, toLong(), toFloat() 등의 변환 함수를 명시적으로 호출할 필요가 없음

예를 들어 42L이나 3.14f처럼 상수 뒤에 타입을 나타내는 접미사(L, f)를 붙이면, 해당 타입으로 자동 인식됨

또한 변수의 타입이 이미 정해져 있거나, 함수 파라미터가 특정 타입으로 선언되어 있다면, 리터럴을 그대로 대입하거나 전달하더라도 컴파일러가 필요한 형변환을 자동으로 처리해 줌

```jsx
val a: Float = 1 // OK, 컴파일러가 자동으로 1.toFloat() 변환해줌
println(a) // 1.0
```

추가로 산술 연산자는 적당한 타입의 값을 받아들일 수 있게 이미 오버로드 되어있음

```jsx
val a: Int = 10
val b: Float = 3.5f
val result = a + b // Float로 자동 변환되어 연산 가능
println(result) // 13.5
```

Kotlin도 Java처럼 산술 연산 중 숫자의 최대/최소 범위를 넘어서면 오버플로우가 발생하고, 기본 연산에서는 이를 자동으로 감지하지 않기 때문에 주의가 필요

⇒ val i: Int = 10억 + 14억 같은 코드는 컴파일은 되지만, 오버플로우로 인해 잘못된 값이 저장되므로 주의해야 함

### Any 타입

---

Java에서는 Object가 클래스 계층의 최상위 타입이지만, `참조 타입만 이 계층에 포함`되고, `원시 타입은 포함되지 않음`

하지만, Kotlin에서는 `Any가 모든 non-null 타입의 최상위 타입`이며, `원시 타입까지 포함한` 모든 타입의 공통 조상임

코틀린에서는 Any 타입 변수에 원시 타입 값을 대입하면 자동으로 값을 객체로 바꿔줌

( `val answer: Any = 42` ⇒ Any가 참조 타입이기에, 42가 박싱됨 )

내부에서 Any 타입은 java.lang.Object에 대응하며, 자바 메서드에서 Object를 인자로 받거나 반환하면 코틀린에서는 Any!로 취급함

모든 클래스에서는 Any에 정의된 메서드인 toString(), equals(), hashCode() 메서드를 사용할 수 있음

**베이스 클래스 Any** 

코틀린의 모든 클래스는 Any 클래스를 상속 받았으며, 이는 Java의 Object와 비슷함

만약 어떤 함수가 여러 타입의 객체를 파라미터로 받는다면 함수의 파라미터를 Any로 설정하면 됨

⇒ 어떤 타입으로 리턴할지 곤란하다면 이때 역시 Any를 리턴하면 됨

⇒ 너무 좋은거 아닌가 ? 하는 생각이 드는데, 이렇기에 아주 제한적으로 사용해야 함

⭐⭐

Any의 목적은 주로 위와 같은 것이 아니라, 일반적으로 모든 코틀린의 타입에 공통으로 적용되는메서드를 만들기 위해 존재

Ex) equals(), hashCode(), toString() … → 모든 타입에서 사용 가능 → Any로 구현되어 있기 때문

Ex2) Pair와 Triple을 사용할 때의 to() 확장 함수 → Any로 구현되어 있음

### **Unit타입 - 코틀린의 void**

---

코틀린의 Unit은 자바 void와 같은 기능을 함

코틀린 함수의 반환 타입이 Unit이고 그 함수가 제네릭 함수를 override 하지 않는다면 그 함수는 내부에서 자바 void 함수로 컴파일 됨

**자바의 void와 Unit의 차이점은 ??**

Kotlin의 Unit은 void와 유사한 개념이지만, 정식 타입으로 간주되는 일반적인 타입임

Unit은 값이 하나뿐이며, 그 값의 이름도 Unit

Kotlin에서 Unit을 반환하는 함수는 타입을 생략할 수 있으며, 하지만 실제로는 Unit이라는 값이 묵시적으로 반환되고 있는 것임 ( 컴파일러가 묵시적으로 return Unit을 넣어줌 )

이처럼 Unit은 제네릭 타입 인자나 반환 타입으로 사용할 수 있어, 제네릭 반환 타입을 요구하는 함수를 오버라이드할 때 유용함

```jsx
interface Callback<T> {
    fun onResult(result: T)
}

// 반환값이 필요 없지만, T는 있어야 할 때
// 자바의 void는 제네릭에 못 쓰지만, Kotlin은 Unit 덕분에 가능
// Unit 값을 반환하기 때문에 
class MyCallback : Callback<Unit> {
    override fun onResult(result: Unit) {
        println("작업 완료")
    }
}
```

### **Nothing 타입 - 정상적으로 종료되지 않음**

---

어떤 함수는 `무조건 예외를 던지거나`, `프로그램을 종료하는 등` 절대로 호출자에게 어떤 값도 돌려줄 수 없는, 정상적으로 값을 반환할 수 없는 구조를 가지는 경우가 있는데, 이럴 때 반환 타입을 Nothing으로 지정

```jsx
fun fail(message: String): Nothing {
	throw Illegal..Exception(message)
}
```

Nothing은 아무 값도 포함하지 않기 때문에, 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터( 제네릭 )로만 쓸 수 있음

Nothing 타입의 변수를 선언하더라도, 그 변수에 아무 값도 저장할 수 없기에 의미가 없으니까

Nothing을 반환하는 함수를 ?: 우항에 사용하여 전제 조건을 검사할 수 있음

`val address = company.address ?: fail(”no”)` 

→ company.address가 null일 경우 `fail(”no”)` 함수가 address에 할당되므로 이후 코드에서는 address가 null이 아님을 알 수 있게 됨

Nothing은 모든 타입의 하위 타입이기 때문에, Int, Double, String 등 어떤 타입으로도 대체될 수 있음

```llvm
fun computeSqrt(n: Double): Double {
	if (n >= 0) {
		return Math.sqrt(n)
	} else {
		throw RuntimeException("No negative please")
	}
}

=> 반환 형이 Double 이지만 Exception을 반환해도 문제 없음
```
